change.log:Adapt full buffer case in jcmainct.c for use with scaled DCT.
change.log:New scaled DCTs implemented.
change.log:Furthermore, separate scaled DCT functions are provided for direct resolving
cjpeg.1:Scale the output image by a factor M/N.  Currently supported scale factors are
djpeg.1:Scale the output image by a factor M/N.  Currently supported scale factors are
djpeg.1:baseline JPEG.  If the /N part is omitted, then M specifies the DCT scaled
example.c:   * the data.  After jpeg_start_decompress() we have the correct scaled
install.txt:     code works too; it scales 8-bit GIF data to and from 12-bit depth
install.txt:with PPM_NORAWWORD defined; then the data is scaled down to 8 bits to make a
jccolor.c: * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
jcdctmgr.c:/* The current scaled-DCT routines require ISLOW-style divisor tables,
jcdctmgr.c:	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
jcdctmgr.c:	 *   scalefactor[0] = 1
jcdctmgr.c:	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
jcdctmgr.c:	 * We apply a further scale factor of 8.
jcdctmgr.c:	  /* precomputed values scaled up by 14 bits */
jcdctmgr.c:	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
jcdctmgr.c:	 *   scalefactor[0] = 1
jcdctmgr.c:	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
jcdctmgr.c:	 * We apply a further scale factor of 8.
jcmaster.c:     * scale down the chroma components via DCT scaling rather than downsampling.
jcparam.c:		      int scale_factor, boolean force_baseline)
jcparam.c: * a scale factor (given as a percentage).
jcparam.c:    temp = ((long) basic_table[i] * scale_factor + 50L) / 100L;
jcparam.c: * and straight percentage-scaling quality scales.
jcparam.c:jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
jcparam.c: * and a straight percentage-scaling quality scale.  In most cases it's better
jcparam.c:		       scale_factor, force_baseline);
jcparam.c:		       scale_factor, force_baseline);
jcsample.c:   * factors are scaled by 2^16 = 65536.
jcsample.c:  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
jcsample.c:  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */
jcsample.c:      /* form final output scaled up by 2^16 */
jcsample.c:  memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */
jcsample.c:  neighscale = cinfo->smoothing_factor * 64; /* scaled SF */
jdcolor.c: * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
jdcolor.c: * values for the G calculation are left scaled up, since we must add them
jdcolor.c:    /* Cr=>G value is scaled-up -0.71414 * x */
jdcolor.c:    /* Cb=>G value is scaled-up -0.34414 * x */
jdct.h: * The DCT outputs are returned scaled up by a factor of 8; they therefore
jdct.h:#define IFAST_SCALE_BITS  2	/* fractional bits in scale factors */
jdct.h:typedef INT32 IFAST_MULT_TYPE;	/* need 32 bits for scaled quantizers */
jdct.h:#define IFAST_SCALE_BITS  13	/* fractional bits in scale factors */
jdct.h: * Fractional constants are scaled left by CONST_BITS bits.
jdct.h:/* Convert a positive real constant to an integer scaled by CONST_SCALE.
jdct.h:/* Descale and correctly round an INT32 value that's scaled by N bits.
jddctmgr.c:/* The current scaled-IDCT routines require ISLOW-style multiplier tables,
jddctmgr.c:	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
jddctmgr.c:	 *   scalefactor[0] = 1
jddctmgr.c:	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
jddctmgr.c:	 * For integer operation, the multiplier table is to be scaled by
jddctmgr.c:	  /* precomputed values scaled up by 14 bits */
jddctmgr.c:	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
jddctmgr.c:	 *   scalefactor[0] = 1
jddctmgr.c:	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
jddctmgr.c:	 * We apply a further scale factor of 1/8.
jdmainct.c: * row group (times any additional scale factor that the upsampler is
jdmainct.c: * by adjusting the DCT_scaled_size values, so that the actual scale factor at
jdmaster.c:  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
jdmaster.c:   * scale up the chroma components via IDCT scaling rather than upsampling.
jdmerge.c:    /* Cr=>G value is scaled-up -0.71414 * x */
jdmerge.c:    /* Cb=>G value is scaled-up -0.34414 * x */
jdsample.c: * if the upsampler is applying a scale factor of its own).
jerror.h:JMESSAGE(JERR_BAD_DCTSIZE, "DCT scaled block size %dx%d not supported")
Binary file jerror.o matches
jfdctflt.c: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
jfdctflt.c: * scaled quantization values.  However, that problem does not arise if
jfdctfst.c: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
jfdctfst.c: * accuracy is lost due to imprecise representation of the scaled
jfdctfst.c: * precise the scaled value, so this implementation does worse with high-
jfdctint.c: * scaled fixed-point arithmetic, with a minimal number of shifts.
jfdctint.c: * We must scale the output coefficients of the N-point FDCT appropriately
jfdctint.c: * The outputs of the first pass are scaled up by PASS1_BITS bits so that
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/7)**2 = 64/49, which we fold
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/6)**2 = 16/9, which we fold
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We scale the results further by 2 as part of output adaption */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/5)**2 = 64/25, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We must also scale the output by (8/4)**2 = 2**2, which we add here. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We scale the results further by 2**2 as part of output adaption */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/3)**2 = 64/9, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT. */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/2)**2 = 2**4.
jfdctint.c:  /* We leave the result scaled up by an overall factor of 8. */
jfdctint.c:  /* We must also scale the output by (8/1)**2 = 2**6. */
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* we scale the results further by 2 as part of output adaption */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/9)**2 = 64/81, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* we scale the results further by 2 as part of output adaption */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/10)**2 = 16/25, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* we scale the results further by 2 as part of output adaption */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/11)**2 = 64/121, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT. */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/12)**2 = 4/9, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT. */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/13)**2 = 64/169, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT. */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/14)**2 = 16/49, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT. */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/15)**2 = 64/225, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/16)**2 = 1/2**2.
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by 8/16 = 1/2.
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/14)*(8/7) = 32/49, which we
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/12)*(8/6) = 8/9, which we
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/10)*(8/5) = 32/25, which we
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We must also scale the output by 8/4 = 2, which we add here. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We scale the results further by 2 as part of output adaption */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/6)*(8/3) = 32/9, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We must also scale the output by (8/4)*(8/2) = 2**3, which we add here. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:  /* We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/2)*(8/1) = 2**5.
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by 8/16 = 1/2.
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/7)*(8/14) = 32/49, which we
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/6)*(8/12) = 8/9, which we
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/5)*(8/10) = 32/25, which we
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We must also scale the output by 8/4 = 2, which we add here. */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT; */
jfdctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jfdctint.c:  /* We scale the results further by 2 as part of output adaption */
jfdctint.c:   * We remove the PASS1_BITS scaling, but leave the results scaled up
jfdctint.c:   * We must also scale the output by (8/6)*(8/3) = 32/9, which we partially
jfdctint.c:  /* Note results are scaled up by sqrt(8) compared to a true DCT. */
jfdctint.c:  /* We must also scale the output by (8/2)*(8/4) = 2**3, which we add here. */
jfdctint.c:   * We leave the results scaled up by an overall factor of 8.
jfdctint.c:  /* We leave the results scaled up by an overall factor of 8.
jfdctint.c:   * We must also scale the output by (8/1)*(8/2) = 2**5.
jidctflt.c: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
jidctflt.c: * scaled quantization values.  However, that problem does not arise if
jidctflt.c:     * DC coefficient (with scale factor as needed).
jidctfst.c: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
jidctfst.c: * accuracy is lost due to imprecise representation of the scaled
jidctfst.c: * precise the scaled value, so this implementation does worse with high-
jidctfst.c: * factors have been incorporated.  We represent them scaled up by PASS1_BITS,
jidctfst.c:     * DC coefficient (with scale factor as needed).
jidctfst.c:    /* Final output stage: scale down by a factor of 8 and range-limit */
jidctint.c: * scaled fixed-point arithmetic, with a minimal number of shifts.
jidctint.c: * The outputs of the first pass are scaled up by PASS1_BITS bits so that
jidctint.c: * with the recommended scaling.  (To scale up 12-bit sample data further, an
jidctint.c:  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
jidctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jidctint.c:     * DC coefficient (with scale factor as needed).
jidctint.c:  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
jidctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jidctint.c:     * DC coefficient (with scale factor as needed).
jidctint.c:  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
jidctint.c:  /* furthermore, we scale the results by 2**PASS1_BITS. */
jidctint.c:     * DC coefficient (with scale factor as needed).
jpeglib.h:  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
jpeglib.h:  JDIMENSION jpeg_width;	/* scaled JPEG image width */
jpeglib.h:  JDIMENSION jpeg_height;	/* scaled JPEG image height */
jpeglib.h:   * and corresponding scale factors (percentage, initialized 100).
jpeglib.h:  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
jpeglib.h:  JDIMENSION output_width;	/* scaled image width */
jpeglib.h:  JDIMENSION output_height;	/* scaled image height */
jpeglib.h:					  int scale_factor,
jpeglib.h:				       int scale_factor,
jpegtran.1:Currently supported scale factors are M/N with all M from 1 to 16, where N is
jpegtran.1:then M specifies the DCT scaled size to be applied on the given input.  For
jpegtran.c:static char * scaleoption;	/* -scale switch */
jpegtran.c:  scaleoption = NULL;
jpegtran.c:      scaleoption = argv[argn];
jquant2.c: * To improve the visual quality of the results, we actually work in scaled
jquant2.c: * B.  To do everything in integer math, we must use integer scale factors.
jquant2.c: * The 2/3/1 scale factors used here correspond loosely to the relative
jquant2.c: * probably need to change these scale factors.
jquant2.c:#define R_SCALE 2		/* scale R distances by this much */
jquant2.c:#define G_SCALE 3		/* scale G distances by this much */
jquant2.c:   * after which, we scale according to the selected distance scale factors.
jquant2.c:     * Current algorithm: longest scaled axis.
libjpeg.txt:returned image to be scaled and allow various speed/quality tradeoffs to be
libjpeg.txt:	output_width		image width and height, as scaled
libjpeg.txt:	quality setting.  The quality value is expressed on the 0..100 scale
libjpeg.txt:jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
libjpeg.txt:	specified scale factor (which is expressed as a percentage; thus
libjpeg.txt:	recommend linear scaling as a user-visible quality scale otherwise.
libjpeg.txt:	Converts a value on the IJG-recommended quality scale to a linear
libjpeg.txt:		      int scale_factor, boolean force_baseline)
libjpeg.txt:	multiplied by scale_factor/100 and then clamped to the range 1..65535
libjpeg.txt:unsigned int scale_num, scale_denom
libjpeg.txt:	Scale the image by the fraction scale_num/scale_denom.  Default is
libjpeg.txt:	Note that the q_scale_factor[] fields are the "linear" scales, so you
libjpeg.txt:unsigned int scale_num, scale_denom
libjpeg.txt:	Scale the image by the fraction scale_num/scale_denom.  Currently,
libjpeg.txt:	this is 8/8.  If you change only the scale_num value while leaving
libjpeg.txt:	the other unchanged, then this specifies the DCT scaled size to be
libtool:	  # though. Also, the filter scales superlinearly with the number of
libtool:	      # though. Also, the filter scales superlinearly with the number of
ltmain.sh:	  # though. Also, the filter scales superlinearly with the number of
ltmain.sh:	      # though. Also, the filter scales superlinearly with the number of
rdppm.c: * In all cases, input is scaled to the size of JSAMPLE.
structure.txt:  When scaled-down output is asked for, simplified DCT algorithms may be used
usage.txt:			supported scale factors are M/N with all N from 1 to
usage.txt:			supported scale factors are M/N with all M from 1 to
usage.txt:			specifies the DCT scaled size to be applied on the
usage.txt:Currently supported scale factors are M/N with all M from 1 to 16, where N is
usage.txt:then M specifies the DCT scaled size to be applied on the given input.  For
wizard.txt:as examples in the JPEG standard) and scales them up or down according to
wizard.txt:can get scaled up to values exceeding 255.  Although 2-byte quantization
wizard.txt:wide compatibility of low-quality files, you can constrain the scaled
wizard.txt:tables taken from the file are scaled in the same fashion that the default
wizard.txt:tables would be scaled for that quality setting.  If -baseline appears, then
wrbmp.c: * To support 12-bit JPEG data, we'd have to scale output down to 8 bits.
wrtarga.c: * To support 12-bit JPEG data, we'd have to scale output down to 8 bits.
